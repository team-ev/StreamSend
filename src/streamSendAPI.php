<?php

namespace TeamEV\StreamSend;

/**
 * This File contains both the SteamSendAPIConnection Class and the StreamSendAPIResponse Class.
 *
 * @package PHP-StreamSend-Connector
 */

/**
 * Constant used when creating a connection object to set the format of the response object's data.
 * This value will return the xml as a string.
 */
define('STREAMSEND_API_TYPE_STRING', 1);

/**
 * Constant used when creating a connection object to set the format of the response object's data.
 * This value will return the xml as a Simple XML Object.
 */
define('STREAMSEND_API_TYPE_SIMPLXML', 2);

/**
 * This class handles connections to the StreamSend API Server.
 *
 * Usage example:
 * <code>
 *  $streamsend = new StreamSendAPIConnection($api_login_id,$api_key);
 *  $response = $streamsend->request('/audiences');
 *
 *  if((!count($response->errors)) && $response->status == 200)){
 *    $xmlObj = $response->data;
 *  }else{
 *    // Any errors generated by the Curl Library,
 *    // StreamSendAPI Server, or the SimpleXML parser
 *    // will be stored in the $response->errors array.
 *  }
 * </code>
 *
 * @package PHP-StreamSend-Connector
 */
class StreamSendAPIConnection{
  
  /**
   * @var Integer Sets the default format of the data in the response object. The allowed values are
   * STREAMSEND_API_TYPE_STRING: The raw xml received from the StreamSend API Server as a string,
   * STREAMSEND_API_TYPE_SIMPLXML: A SimpleXML Object The returned xml as parsed by PHP's simplexml_load_string function
   */
  public $response_parse_type;
  
  /**
   * @var String StreamSend API Login ID
   */
  public $login_id;
  
  /**
   * @var String StreamSend API Key
   */
  public $key;
  
  /**
   * @var Mixed Curl Handle
   */
  public $curl;
  
  /**
   * @var Integer Default audience_id for connection
   */
  public $audience_id;
  
  /**
   * @var String Stores the last uri requested.
   */
  public $uri;
  
  /**
   * @param String login_id StreamSend API Login ID
   * @param String key StreamSend API Key
   * @param Integer response_parse_type constant that specifies the format the response object's data property.
   * @param Integer audience_id if this value is set requested urls can contain /audiences/{audience_id}/people/123 and the audience_id value will be automatically inserted. If it is not defined this object will have to get that value from the API just before the first request. (Storing it locally save a round trip to the API server)
   */
  public function __construct($login_id, $key, $response_parse_type=STREAMSEND_API_TYPE_SIMPLXML,$audience_id=null){
    $this->login_id = $login_id;
    $this->key = $key;
    $this->response_parse_type = $response_parse_type;
    $this->audience_id = $audience_id;
    $this->init_curl();
  }
  
  /**
   * @param String $uri URI to request from the StreamSend API Server, relative to the API root (ie /audiences/)
   * @param String $method HTTP method of the request
   * @param Mixed $data XML string, associative array, or SimpleXMLElement Object representing the xml to send to the StreamSend API Server
   * @param Integer $response_parse_type If set will override the current response_parse_type of this StreamSendConnection object just for this request.
   */
  public function request($uri, $method = 'GET', $data = null, $response_parse_type = null, $headers = null, $is_file_upload = false){
    $this->init_curl();
    if(stripos($uri,'{audience_id}') !== false){
      $uri = str_replace('{audience_id}',$this->audience_id(),$uri);
    }
    $this->uri = $uri;
    curl_setopt($this->curl, CURLOPT_CUSTOMREQUEST, $method);
    curl_setopt($this->curl, CURLOPT_URL, 'https://app.streamsend.com'.$uri);

    if ($headers) {
      curl_setopt($this->curl, CURLOPT_HTTPHEADER, $headers);
    }

    if($data){
      if (!$is_file_upload) {
        if(is_array($data)){
          $data = $this->array_to_xml($data);
        }elseif(is_a($data,'SimpleXMLElement')){
          $data = $data->asXML();
        }
      }
      curl_setopt($this->curl, CURLOPT_POSTFIELDS, $data);
    } 

    return new StreamSendResponse(curl_exec($this->curl), $this, $response_parse_type);
  }
  
  /**
   * Sets up a curl object to communicate with the StreamSend API Server
   */
  protected function init_curl(){
    $this->curl = curl_init();
    curl_setopt($this->curl, CURLOPT_USERPWD, "{$this->login_id}:{$this->key}");
    curl_setopt($this->curl, CURLOPT_SSL_VERIFYPEER, false);
    curl_setopt($this->curl, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($this->curl, CURLOPT_HTTPHEADER, array('Accept: application/xml','Content-Type: application/xml'));
    curl_setopt($this->curl, CURLOPT_HEADER,true);
  }
  
  /**
   * Converts an associative array to a simple xml structure
   */
  public function array_to_xml($a){
    $lines = array();
    foreach($a as $k => $v){
      $line = '<'.$k.'>';
      if(is_array($v)){
        $line.="\n".$this->array_to_xml($v)."\n";
      }else{
        $line.=$v;
      }
      $lines[] = $line.'</'.$k.'>';
    }

    return implode("\n",$lines);
  }
  
  /**
   * This function returns the audience id. If this StreamSendAPIConnection object does not already know
   * the audience id it will get it from the API and store it so it can be automatically inserted in
   * subsequent calls to the API. ( A url containing {audience_id} will be automatically substituted )
   */
  public function audience_id(){
    if($this->audience_id){return $this->audience_id;}
    $r = $this->request('/audiences','GET',null, STREAMSEND_API_TYPE_SIMPLXML);
    if($audience_id = intval((String) $r->data->audience[0]->id)){
      $this->audience_id = $audience_id;
    }
    return $this->audience_id;
  }
  
  public function ping(){
    return $this->request('/audiences.xml')->status == 200;
  }

  /**
   * Creates a new person with the given attributes.
   * @param  string  $email              Email
   * @param  string  $first_name         First name
   * @param  string  $last_name          Last name
   * @param  boolean $activate           If false, the person will be created with a status of pending
   * @param  boolean $deliver_activation If activate is false, setting this to true will trigger the sending of the built-in activation notification. If activate is true, this setting has no effect
   * @param  boolean $deliver_welcome    If activate is true, setting this to true will trigger the sending of the built-in welcome notification. If activate is false, this setting has no effect
   * @return mixed                       Person id or a respons errors as array
   */
  public function create_person($email, $data = array()){
    $method = 'POST';
    $uri = "/audiences/{$this->audience_id()}/people.xml";
    $data = $data + array(
          'email-address' => $email,
          'first-name' => '',
          'last-name' => '',
          'activate' => true,
          'deliver-activation' => false,
          'deliver-welcome' => false,
          );

    $params = array('person' => $data);

    $response = $this->request($uri, $method, $params);

    if ($response->errors) {
      return $response->errors;
    }
    
    if (preg_match('@^Location: (.*)$@m', $response->raw_headers, $matches)) {
      $location = trim($matches[1]);
      return substr($location, strrpos($location, '/') + 1);
    }
  }

  /**
   * Deletes a person, as well as their associated attributes and list membership history.
   * @param  int $id Id of the person
   * @return int     Response status: 200 - OK, 423 - Locked
   */
  public function delete_person($id){
    $method = 'DELETE';
    $uri = "/audiences/{$this->audience_id()}/people/{$id}.xml";
    //TODO: Make more informative answer
    return $this->request($uri, $method, null, 2)->status;
  }

  /**
   * Get all data for person by email
   * @param  string $email Email of the person
   * @return StreamSendResponse        Returns StreamSendResponse
   */
  public function get_person_data($email){
    $uri = "/audiences/1/people?email_address=$email";
    $method = 'GET';

    return $this->request($uri, $method, null, 2);//->data->person;
  }

  /**
   * Activates person (Can recive emails)
   * @param  int $id ID of the person
   * @return int     Response code 200 - OK
   */
  public function activate_person($id){
    $uri = "/audiences/{$this->audience_id()}/people/{$id}/activate.xml";
    $method = 'POST';

    return $this->request($uri, $method)->status;
  }
  
  /**
   * Deactivate a person (Cannot recive emails)
   * @param  int $id ID of the person
   * @return int     Response code - 200 - OK
   */
  public function deactivate_person($id){
    $uri = "/audiences/{$this->audience_id()}/people/{$id}/unsubscribe.xml";
    $method = 'POST';

    return $this->request($uri, $method)->status;
  }

  
  public function update_person($id, $data){
    if (empty($data)) {
      return;
    }

    $uri = "/audiences/{$this->audience_id()}/people/{$id}.xml";
    $method = 'PUT';

    $params = array('person' => $data);

    $response = $this->request($uri, $method, $params);

    return $response->status;
  }

  /**
   * Uploads file to StreamSend Server
   * @param  string $file_path Full path to the file
   * @return mixed  Returns import id or a respons errors as array           
   */
  public function upload_file($file_path){
    $data = array("data" => "@$file_path");
    $method = "POST";
    $uri = "/uploads.xml";
    $headers = array('Content-Type: multipart/form-data');

    $response = $this->request($uri, $method, $data, STREAMSEND_API_TYPE_STRING, $headers, true);

    //file uploaded successfuly
    if ($response->status == 201) {
      //take uploaded file id
      if (preg_match('@^Location: (.*)$@m', $response->data, $matches)) {
        $location = trim($matches[1]);
        return substr($location, strrpos($location, '/') + 1);
      }
    }
    return $response->errors;
  }

  /**
   * Create a new batch import using a previously uploaded file.
   * @param  int  $upload_id              The ID of the file that was just uploaded and should be used for this import
   * @param  boolean $reactivated         Existing people will be reactivated
   * @param  boolean $ignore_first_row    Skip the first row because it’s a header row
   * @param  boolean $skip_duplicates     Existing people will be ignored
   * @param  boolean $skip_blank_columns  Any blank data will be ignored, leaving existing data alone
   * @param  string  $lists               A comma-delimited list of list ids into which the attached people should be placed
   * @param  string  $separator           May be ‘Comma’, ‘Tab’, or ‘Semi-colon’
   * @return mixed                        Returns import id or a respons errors as array
   */
  public function create_import($upload_id, $lists, $separator, $columns_ids, $reactivate = false, $ignore_first_row = false, 
    $skip_duplicates = false, $skip_blank_columns = false){
    $method = 'POST';
    $uri = "/audiences/{$this->audience_id()}/imports.xml";

    $columns = '';
    foreach ($columns_ids as $value) {
        $columns .= '<column>'.$value.'</column>';
    }

    $data = array('import' => 
        array('separator' => $separator,
              'reactivate' => $reactivate,              
              'lists' => $lists,
              'upload-id' => $upload_id,
              'ignore_first_row' => $ignore_first_row,
              'skip-duplicates' => $skip_duplicates,
              'skip-blank-columns' => $skip_blank_columns,
              'columns' => $columns
            )
      );

    return $response = $this->request($uri, $method, $data, 2);
    // if ($response->errors) {
    //   return $response->errors;
    // }
    // //file imported successfuly
    // //take import id
    // if (preg_match('@^Location: (.*)$@m', $response->raw_headers, $matches)) {
    //   $location = trim($matches[1]);
    //   return substr($location, strrpos($location, '/') + 1);
    // }
  }

  //TODO: Show import status
  
  /**
   * Creates a new list with the given name and an optional description.
   * @param  string $name        Name of the list
   * @param  string $description Description of the list
   * @return int                 Response status code - 201 - Created
   */ 
  public function create_list($name, $description = null){
    $uri = "/audiences/{$this->audience_id()}/lists.xml";
    $method = 'POST';
    $data = array('list' => 
              array(
                'name' => $name,
                'description' => $description
                )
              );

    $response = $this->request($uri, $method, $data);
    //file uploaded successfuly
    //take uploaded file id
    if (preg_match('@^Location: (.*)$@m', $response->raw_headers, $matches)) {
      $location = trim($matches[1]);
      return substr($location, strrpos($location, '/') + 1);
    }
  }

  /**
   * Deletes a particular list, removing all associated membership records.
   * @param  int $id    ID of the list
   * @return int        Response status code - 200 - OK, 404 - Not found
   */
  public function delete_list($id){
    $uri = "/audiences/{$this->audience_id()}/lists/{$id}";
    $method = 'DELETE';

    return $this->request($uri, $method)->status;
  }

  public function get_list_status($list_id){
    $uri = "/audiences/{$this->audience_id()}/lists/{$list_id}.xml";

    return $this->request($uri)->status; //200 -> ok, 404 -> not found
  }

  public function get_list_name($list_id){
    $uri = "/audiences/{$this->audience_id()}/lists/{$list_id}.xml";

    return (string) $this->request($uri, 'GET', NULL, 2)->data->name;
  }

  public function get_lists_data(){
    $uri = "/audiences/{$this->audience_id()}/lists.xml";
    $response = (array) $this->request($uri, 'GET', NULL, 2)->data;

    $lists_data = array();
    $response += array('list' => '');
    $streamsend_lists = $response['list'];

    if (!empty($streamsend_lists)) {
      //when there is only one list, 
      //the stupid API returns a object, instead of array of one element
      if (is_array($streamsend_lists)) {
        foreach ($streamsend_lists as $value) {
          $lists_data[] = array(
            'name' => (string) $value->name,
            'description' => (string) $value->description,
            'id' => (string) $value->id,
            );
        }
      }
      else{
        $lists_data[] = array(
          'name' => (string) $streamsend_lists->name,
          'description' => (string) $streamsend_lists->description,
          'id' => (string) $streamsend_lists->id,
          );
      }
    }

    return $lists_data;
  }

  public function get_person_lists_ids($person_id){
    $uri = "/audiences/{audience_id}/people/$person_id/lists.xml";
    $method = 'GET';

    $response = (array) $this->request($uri, 'GET', NULL, 2)->data;

    $lists_data = array();
    $response += array('list' => '');
    $streamsend_lists = $response['list'];


    if (!empty($streamsend_lists)) {
      //when there is only one list, 
      //the stupid API returns a object, instead of array of one element
      if (is_array($streamsend_lists)) {
        foreach ($streamsend_lists as $value) {
          $lists_data[] = (string) $value->id;
        }
      }
      else{
        $lists_data[] = (string) $streamsend_lists->id;
      }
    }

    return $lists_data;
  }

  public function get_people_by_list($list_id, $page_num = '', $per_page = ''){
    $uri = "/audiences/{audience_id}/lists/$list_id/people";
    if (empty($page_num)) {
      $page_num = '1';
    }
    if (empty($per_page)) {
      $per_page = '1000000000000'; //max people per list
    }
    $uri .= "?page=$page_num&per_page=$per_page.xml";
    $method = 'GET';

    $response = (array) $this->request($uri, $method, null, 2)->data;
    $people_data = array();
    $response += array('person' => '');
    $streamsend_people = $response['person'];


    //when list is empty, api does't add a property 'person' to the response object..
    if (!empty($streamsend_people)) {
    //when there is only one memeber of the list, 
    //the stupid API returns a object, instead of array of one element

        //these are aliases bc the fields names contains hyphen(-)
        $email = 'email-address';
        $opt_status = 'opt-status';
        $updated_at = 'updated-at'; 
        if (is_array($streamsend_people)) {
            foreach ($streamsend_people as $value) {
                $people_data[] = array(
                    'id' => (string) $value->id,
                    'email_address' => (string) $value->$email,
                    'opt_status' => (string) $value->$opt_status,
                    'updated_at' => gmdate('Y-m-d H:i:s',strtotime((string) $value->$updated_at)),
                );
            }
        }
        else{
          $people_data[] = array(
                    'id' => (string) $streamsend_people->id,
                    'email_address' => (string) $streamsend_people->$email,
                    'opt_status' => (string) $streamsend_people->$opt_status,
                    'updated_at' => gmdate('Y-m-d H:i:s',strtotime((string) $streamsend_people->$updated_at)),
                );
        }
    }

    return $people_data;
  }

  public function get_lists_ids(){
    $uri = "/audiences/{$this->audience_id()}/lists.xml";

    $response = $this->request($uri, 'GET', NULL, 2);
    $data = ((array) $response->data);

    $lists_ids = array();
    foreach ($data['list'] as $value) {
      $lists_ids[] = (string) $value->id; 
    }
    return $lists_ids; 
  }

  public function create_membership($person_id, $list_id){
    $uri = "/audiences/{$this->audience_id()}/people/{$person_id}/lists/{$list_id}/memberships.xml";
    $method = 'POST';

    $response = $this->request($uri, $method);
    // if (preg_match('@^Location: (.*)$@m', $response->raw_headers, $matches)) {
    //   $location = trim($matches[1]);
    //   return substr($location, strrpos($location, '/') + 1);
    // }
    // else{
    //   return $response->status;
    // }
    return $response->status;
  }

  public function delete_membership($id){
    $uri = "/audiences/{$this->audience_id()}/memberships/{$id}.xml";
    $method = 'DELETE';

    return $this->request($uri, $method)->status;
  }

  public function get_membership_data($person_id, $list_id){
    $uri = "/audiences/{$this->audience_id()}/people/{$person_id}/lists/{$list_id}/memberships.xml?page=1";
    return $this->request($uri, 'GET', null, 2)->data;
  }

  public function subscribe_to_list($list_id, $email, $data = array(), $double_optin = false, $update_existing=false){

    $person_data = $this->get_person_data($email);

    if ($person_data->errors) {
      return $person_data->errors;
    }
    $person_id = (string) $person_data->data->person->id;

    if ($double_optin) {
      $data = $data + array('activate' => false, 'deliver-activation' => true);
    }

    if (empty($person_id)) {
      //if person don't exist, crete him
      $create_response = $this->create_person($email, $data);
      //error occured
      if (is_array($create_response)) {
        return $create_response;
      }
      $person_id = $create_response;
    }
    else{
      if ($update_existing) {
        $this->update_person($person_id, $data);
      }
    }
    
    return $this->create_membership($person_id, $list_id);
  }

  public function unsubscribe_from_list($list_id, $email){
    $person_data = $this->get_person_data($email);

    if ($person_data->errors) {
      return $person_data->errors;
    }
    $person_id = (string) $person_data->data->person->id;
    if (empty($person_id)) {
      return true; //person not found
    }

    $membership_id = (string) $this->get_membership_data($person_id, $list_id)->membership->id;

    if (empty($membership_id)) {
      return true; //membership not found
    }

    return $this->delete_membership($membership_id);
  }
}

/**
 * This class defines an object that encapsulates the response from the StreamSend API Server.
 *
 * Usage example:
 * <code>
 *  $streamsend = new StreamSendAPIConnection($api_login_id,$api_key);
 *  $response = $streamsend->request('/audiences');
 *
 *  if((!count($response->errors)) && $response->status == 200)){
 *    $xmlObj = $response->data;
 *  }else{
 *    // Any errors generated by the Curl Library,
 *    // StreamSendAPI Server, or the SimpleXML parser
 *    // will be stored in the $response->errors array.
 *  }
 * </code>
 * 
 * @package PHP-StreamSend-Connector
 */
class StreamSendResponse {
  
  /**
   * @var StreamSendAPIConnection StreamSend API Connection object that created this response object
   */
  public $conn;
  
  /**
   * @var String Raw HTTP Headers of the response.
   */
  public $raw_headers;
  
  /**
   * @var Array An associative array of HTTP headers keys and their values. To get this values the method headers() should be called.
   * since this array is not populated unless needed.
   */
  protected $_parsed_headers = null;
  
  /**
   * @var Array Array of connection, parsing errors, or api errors encountered.
   */
  public $errors = array();
  
  /**
   * @var Integer HTTP Status Code of response from the server
   */
  public $status;
  
  /**
   * @var Mixed Results of the query in the format specified by the STREAMSEND_API_TYPE setting of the connection object.
   */
  public $data;
  
  /**
   * @param String Full response including HTTP headers.
   */
  public function __construct($full_response, $conn, $response_parse_type = null){
    if(is_null($response_parse_type)){ $response_parse_type = $conn->response_parse_type; }
    $this->conn = $conn;
    $this->status = curl_getinfo($conn->curl, CURLINFO_HTTP_CODE);
    if($full_response == false){
      $this->errors[] = 'CURL Error # '.curl_errno($this->conn->curl).': '.curl_error($this->conn->curl);
    }
    $t = explode("\r\n\r\n", $full_response);
    $this->raw_headers = $t[0];
    if(isset($t[1])){
      switch($response_parse_type){
        case STREAMSEND_API_TYPE_SIMPLXML:
          if(strlen(trim($t[1]))){
            if(function_exists('libxml_use_internal_errors')){
              libxml_use_internal_errors(true);
            }
            if($xml = simplexml_load_string($t[1])){
              $this->data = $xml;
            }else{
              if(function_exists('libxml_get_errors')){
                foreach(libxml_get_errors() as $error){
                  $this->errors[] = 'SimpleXML Parsing Error: '.$error->message.'( line: '.$error->line.', column: '.$error->column.' )';
                }
              }else{
                $this->errors[] = 'SimpleXML Parsing Error';
              }
            }
          }
          break;
        case STREAMSEND_API_TYPE_STRING:
        default:
          $this->data = $t[1];
          break;
      }
      if($this->status >= 400){
        // checking for errors returned in body of response
        if($response_parse_type == STREAMSEND_API_TYPE_SIMPLXML){
          $xml = $this->data;
        }else{
          if(strlen(trim($t[1]))){
            if(function_exists('libxml_use_internal_errors')){
              libxml_use_internal_errors(true);
            }
            $xml = simplexml_load_string($t[1]);
            if(function_exists('libxml_get_errors')){
              foreach(libxml_get_errors() as $error){
                $this->errors[] = 'SimpleXML Parsing Error: '.$error->message.'( line: '.$error->line.', column: '.$error->column.' )';
              }
            }
            
          }else{
            $this->errors[] = array_shift(explode("\n",$this->raw_headers));
          }
        }
        if($xml){
          foreach($xml->error as $e){$this->errors[]=(String) $e;}
        }
      }
    }
  }
  
  /**
   * Returns an array of HTTP headers that were sent as part of this response.
   */
  public function headers(){
    if(!is_null($this->_parsed_headers)){return $this->_parsed_headers;}
    $this->_parsed_headers = array();
    foreach(explode("\n",$this->raw_headers) as $line){
      $t = explode(':',$line,2);
      $this->_parsed_headers[trim($t[0])] = (isset($t[1])) ? trim($t[1]) : '';
    }
    return $this->_parsed_headers;
  }
}
?>
